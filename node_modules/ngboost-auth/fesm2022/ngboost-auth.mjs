import * as i0 from '@angular/core';
import { Injectable, Inject, NgModule } from '@angular/core';
import { throwError } from 'rxjs';
import { tap, catchError } from 'rxjs/operators';
import * as i1 from '@angular/common/http';
import * as i2 from '@angular/router';

class CookieService {
    constructor() {
        // check if HTML document is available
        this.doc_avail = !!document; // true | false
    }
    /**
     * Show console error
     */
    errNotAvailable() {
        console.error('Document is not available in ng5plus-cookies.');
    }
    /**
     * Add cookie options: domain, path, expires, secure
     * @param cookieStr string
     * @param cookieOpts object
     */
    addCookieOptions(cookieStr, cookieOpts) {
        if (!cookieOpts) {
            return cookieStr;
        }
        // domain=example.com;
        if (!!cookieOpts.domain) {
            const cDomain = 'domain=' + cookieOpts.domain + ';';
            cookieStr += cDomain;
        }
        // path=/;
        if (!!cookieOpts.path) {
            const cPath = 'path=' + cookieOpts.path + ';';
            cookieStr += cPath;
        }
        // expires=Fri, 3 Aug 2001 20:47:11 UTC;
        if (!!cookieOpts.expires) {
            let expires;
            if (typeof cookieOpts.expires === 'number') {
                const d = new Date();
                d.setTime(d.getTime() + (cookieOpts.expires * 24 * 60 * 60 * 1000));
                expires = 'expires=' + d.toUTCString();
            }
            else {
                expires = cookieOpts.expires.toUTCString();
            }
            const cExpires = 'expires=' + expires + ';';
            cookieStr += cExpires;
        }
        // secure;
        if (!!cookieOpts.secure) {
            const cSecure = 'secure;';
            cookieStr += cSecure;
        }
        // HttpOnly;
        if (!!cookieOpts.httpOnly) {
            const cHttpOnly = 'HttpOnly;';
            cookieStr += cHttpOnly;
        }
        // SameSite=lax; or SameSite=strict;
        if (!!cookieOpts.sameSite) {
            const cSameSite = 'SameSite=' + cookieOpts.sameSite + ';';
            cookieStr += cSameSite;
        }
        return cookieStr;
    }
    /**
     * Get all cookies in array format.
     * @return Array
     */
    allCookiesArr() {
        // fetch all cookies
        const allCookies = document.cookie; // authAPIInit1=jedan1; authAPIInit2=dva2; authAPI=
        // create cookie array
        const cookiesArr = allCookies.split(';'); // ["authAPIInit1=jedan1", " authAPIInit2=dva2", " authAPI="]
        // remove empty spaces from left and right side
        const cookiesArrMapped = cookiesArr.map((cookiesPair) => {
            return cookiesPair.trim();
        });
        return cookiesArrMapped; // ["authAPIInit1=jedan1", "authAPIInit2=dva2", "authAPI="]
    }
    /**
     * Set cookie. Cookie value is string.
     * @param name - cookie name
     * @param value - cookie value (string)
     * @param cookieOpts - cookie options: domain, path, expires, secure, HttpOnly, SameSite
     * @param debug - true | false (show errors and debug info)
     */
    put(name, value, cookieOpts, debug) {
        if (!this.doc_avail) {
            if (debug) {
                this.errNotAvailable();
            }
            return;
        }
        // encoding cookie value
        value = encodeURIComponent(value);
        // name=value;
        let cookieStr = name + '=' + value + ';';
        // add cookie options: domain, path, expires, secure, HttpOnly, SameSite
        cookieStr = this.addCookieOptions(cookieStr, cookieOpts);
        // debug
        if (debug) {
            console.log('cookie-put():cookieStr: ', cookieStr);
        }
        // put cookie
        document.cookie = cookieStr;
    }
    /**
     * Set cookie. Cookie value is object.
     * @param name - cookie name
     * @param value - cookie value (object)
     * @param cookieOpts - cookie options: domain, path, expires, secure, HttpOnly, SameSite
     * @param debug - true | false (show errors and debug info)
     */
    putObject(name, value, cookieOpts, debug) {
        if (!this.doc_avail) {
            if (debug) {
                this.errNotAvailable();
            }
            return;
        }
        // convert object to string and encode that string
        const valueStr = encodeURIComponent(JSON.stringify(value));
        // name=value;
        let cookieStr = name + '=' + valueStr + ';';
        // add cookie options: domain, path, expires, secure, HttpOnly, SameSite
        cookieStr = this.addCookieOptions(cookieStr, cookieOpts);
        // debug
        if (debug) {
            console.log('cookie-putObject(): ', cookieStr);
        }
        // put cookie
        document.cookie = cookieStr;
    }
    /**
     * Get all cookies in string format (cook1=jedan1; cook2=dva2;).
     * @param debug - true | false (show errors and debug info)
     * @return string - example: cook1=jedan1; cook2=dva2;
     */
    getAll(debug) {
        if (!this.doc_avail) {
            if (debug) {
                this.errNotAvailable();
            }
            return '';
        }
        // fetch all cookies
        const allCookies = document.cookie; // 'cook1=jedan1; cook2=dva2;'
        // debug
        if (debug) {
            console.log('cookie-getAll(): ', allCookies);
        }
        return allCookies;
    }
    /**
     * Get cookie by specific name. Returned value is string.
     * @param name - cookie name
     * @param debug - true | false (show errors and debug info)
     * @return string
     */
    get(name, debug) {
        if (!this.doc_avail) {
            if (debug) {
                this.errNotAvailable();
            }
            return '';
        }
        // get cookies array
        const cookiesArr = this.allCookiesArr(); // ["authAPIInit1=jedan1", "authAPIInit2=dva2", "authAPI="]
        // extract cookie value for specific name
        let elemArr, cookieVal = '';
        cookiesArr.forEach(function (elem) {
            elemArr = elem.split('='); // ["authAPIInit1", "jedan1"]
            if (elemArr[0] === name) {
                cookieVal = elemArr[1] || '';
            }
        });
        // decoding cookie value
        cookieVal = decodeURIComponent(cookieVal);
        // debug
        if (debug) {
            console.log('cookie-get()-cookiesArr: ', cookiesArr);
            console.log('cookie-get()-cookieVal: ', name, '=', cookieVal);
        }
        return cookieVal;
    }
    /**
     * Get cookie by specific name. Returned value is object.
     * @param name - cookie name
     * @param debug - true | false (show errors and debug info)
     * @return object
     */
    getObject(name, debug) {
        if (!this.doc_avail) {
            if (debug) {
                this.errNotAvailable();
            }
            return null;
        }
        const cookieVal = this.get(name, debug); // %7B%22jen%22%3A1%2C%22dva%22%3A%22dvica%22%7D
        // convert cookie string value to object
        let cookieObj = null;
        try {
            if (cookieVal !== 'undefined' && !!cookieVal) {
                cookieObj = JSON.parse(decodeURIComponent(cookieVal));
            }
        }
        catch (err) {
            console.error('cookie-getObject(): ', err);
        }
        // debug
        if (debug) {
            console.log('cookie-getObject():cookieVal: ', cookieVal);
            console.log('cookie-getObject():cookieObj: ', cookieObj);
        }
        return cookieObj;
    }
    /**
     * Remove cookie by specific name.
     * @param name - cookie name
     * @param debug - true | false (show errors and debug info)
     * @return void
     */
    remove(name, debug) {
        if (!this.doc_avail) {
            if (debug) {
                this.errNotAvailable();
            }
            return;
        }
        // set expires backward to delete cookie
        const dateOld = new Date('1970-01-01T01:00:00');
        // debug
        if (debug) {
            console.log('cookie-remove(): ', name, ' cookie is deleted.');
        }
        // cookie removal
        document.cookie = name + '=;expires=' + dateOld + '; path=/;';
    }
    /**
     * Remove all cookies.
     * @param debug - true | false (show errors and debug info)
     * @return void
     */
    removeAll(debug) {
        if (!this.doc_avail) {
            if (debug) {
                this.errNotAvailable();
            }
            return;
        }
        // set expires backward to delete cookie
        const dateOld = new Date('1970-01-01T01:00:00').toUTCString();
        // get cookies array
        const cookiesArr = this.allCookiesArr(); // ["authAPIInit1=jedan1", "authAPIInit2=dva2", "authAPI="]
        // extract cookie value for specific name
        let elemArr;
        const cookiesArr2 = [];
        cookiesArr.forEach(function (elem) {
            elemArr = elem.split('='); // ["authAPIInit1", "jedan1"]
            document.cookie = elemArr[0] + '=;expires=' + dateOld + '; path=/;';
            cookiesArr2.push(document.cookie);
        });
        // debug
        if (debug) {
            console.log('cookie-removeAll():before:: ', cookiesArr);
            console.log('cookie-removeAll():after:: ', cookiesArr2);
        }
    }
    /**
     * Empty cookie value by specific name.
     * @param name - cookie name
     * @param debug - true | false (show errors and debug info)
     * @return void
     */
    empty(name, debug) {
        if (!this.doc_avail) {
            if (debug) {
                this.errNotAvailable();
            }
            return;
        }
        // empty cookie value
        document.cookie = name + '=;';
        // debug
        if (debug) {
            console.log('cookie-empty(): ', name);
        }
    }
    /**
     * Check if cookie exists.
     * @param name - cookie name
     * @param debug - true | false (show errors and debug info)
     * @return boolean
     */
    exists(name, debug) {
        if (!this.doc_avail) {
            if (debug) {
                this.errNotAvailable();
            }
            return false;
        }
        // get cookies array
        const cookiesArr = this.allCookiesArr(); // ["authAPIInit1=jedan1", "authAPIInit2=dva2", "authAPI="]
        // extract cookie value for specific name
        let elemArr, cookieExists = false;
        cookiesArr.forEach(function (elem) {
            elemArr = elem.split('='); // ["authAPIInit1", "jedan1"]
            if (elemArr[0] === name) {
                cookieExists = true;
            }
        });
        // debug
        if (debug) {
            console.log('cookie-exists(): ', cookieExists);
        }
        return cookieExists;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: CookieService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: CookieService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: CookieService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [] });

class AuthService {
    constructor(http, cookieService, r, auth_urls) {
        this.http = http;
        this.cookieService = cookieService;
        this.r = r;
        this.auth_urls = auth_urls;
        this.cookieOpts = {
            // domain: 'localhost',
            path: '/',
            expires: 3,
            // expires: new Date('2018-10-31T03:24:00'),
            secure: false,
            httpOnly: false,
            sameSite: 'strict'
        };
    }
    /**
     * Login with username and password
     * @param creds // credentials object {username: xxx, password: xxx}
     * @return Observable
     */
    login(creds) {
        return this.http.post(this.auth_urls.apiLoginUrl, creds).pipe(tap((apiResp) => {
            /* set cookie 'auth_jwtToken': 'JWT xyz...' */
            if (!!apiResp && !!apiResp.jwtToken) {
                this.cookieService.put('auth_jwtToken', apiResp.jwtToken, this.cookieOpts, false);
            }
            /* set cookie 'auth_loggedUser' and class property 'this.loggedUser': {first_name: , last_name: , ...} */
            if (!!apiResp && !!apiResp.loggedUser) {
                this.cookieService.putObject('auth_loggedUser', apiResp.loggedUser, this.cookieOpts, false);
                this.loggedUser = apiResp.loggedUser;
            }
            /* redirect to URL */
            const afterGoodLoginURL = this.auth_urls.afterGoodLogin.replace('{loggedUserRole}', apiResp.loggedUser.role);
            this.r.navigateByUrl(afterGoodLoginURL);
        }), catchError((err) => {
            /* remove all cookies */
            this.cookieService.removeAll(false);
            /* remove loggedUser class property */
            this.loggedUser = null;
            // return error
            return throwError(() => err);
        }));
    }
    /**
     * Logout
     * @return Observable
     */
    logout() {
        // delete all cookies
        this.cookieService.removeAll(false);
        // delete class property
        this.loggedUser = null;
        // redirect
        setTimeout(() => {
            const afterLogoutURL = this.auth_urls.afterLogout;
            this.r.navigateByUrl(afterLogoutURL);
        }, 300);
    }
    /**
     * Get logged user info (from global variables or cookie)
     * @return object - {first_name: , last_name: , ...}
     */
    getLoggedUserInfo() {
        const loggedUser = this.loggedUser || this.cookieService.getObject('auth_loggedUser', false);
        return loggedUser;
    }
    /**
     * Get JWT token from cookie
     * @return string - JWT eyJhbGciOiJIUzI1NiIsInR...
     */
    getJWTtoken() {
        const jwtToken = this.cookieService.get('auth_jwtToken', false) || 'JWT ';
        return jwtToken;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: AuthService, deps: [{ token: i1.HttpClient }, { token: CookieService }, { token: i2.Router }, { token: 'AUTH_URLS' }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: AuthService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: AuthService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i1.HttpClient }, { type: CookieService }, { type: i2.Router }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['AUTH_URLS']
                }] }] });

/**
 * Intercept every HTTP erquest.
 */
class JwtTokenInterceptor {
    constructor(authService) {
        this.authService = authService;
    }
    intercept(req, next) {
        const jwtToken = this.authService.getJWTtoken();
        req = req.clone({
            setHeaders: {
                Authorization: jwtToken
            }
        });
        return next.handle(req);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: JwtTokenInterceptor, deps: [{ token: AuthService }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: JwtTokenInterceptor }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: JwtTokenInterceptor, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: AuthService }] });

/**
 * Check if user is logged.
 */
class IsLoggedService {
    constructor(authService, r, auth_urls) {
        this.authService = authService;
        this.r = r;
        this.auth_urls = auth_urls;
    }
    canActivate(ars, rss) {
        // get loggedUser info after successful username:password login
        const loggedUser = this.authService.getLoggedUserInfo();
        // console.log('GUARD::isLogged:loggedUser: ', loggedUser);
        const isAlreadyLogged = !!loggedUser && !!loggedUser.username;
        // redirect to /login
        if (!isAlreadyLogged) {
            this.r.navigateByUrl(this.auth_urls.afterBadLogin);
            console.error(new Error('Guard blocks this route because user is not logged. Redirection to /login page.'));
        }
        return isAlreadyLogged;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: IsLoggedService, deps: [{ token: AuthService }, { token: i2.Router }, { token: 'AUTH_URLS' }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: IsLoggedService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: IsLoggedService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: AuthService }, { type: i2.Router }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['AUTH_URLS']
                }] }] });

/**
 * Check if user has required role: admin, customer. If not redirect to /login page.
 */
class HasRoleService {
    constructor(authService, r, auth_urls) {
        this.authService = authService;
        this.r = r;
        this.auth_urls = auth_urls;
    }
    canActivate(ars, rss) {
        // get loggedUser info after successful username:password login
        const loggedUser = this.authService.getLoggedUserInfo();
        // console.log('GUARD::hasRole:loggedUser: ', loggedUser);
        // get current URL and check if user's role (admin, customer) is contained in it
        const currentUrl = rss.url; // '/admin/dashboard'
        // console.log('GUARD::hasRole:currentUrl: ', currentUrl);
        let tf = false;
        if (loggedUser) {
            tf = currentUrl.indexOf(loggedUser.role) !== -1;
        }
        if (!tf) {
            this.r.navigateByUrl(this.auth_urls.afterBadLogin);
            console.error(new Error('Guard blocks this route because user doesn\'t have good role. Redirection to /login page.'));
        }
        return tf;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: HasRoleService, deps: [{ token: AuthService }, { token: i2.Router }, { token: 'AUTH_URLS' }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: HasRoleService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: HasRoleService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: AuthService }, { type: i2.Router }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['AUTH_URLS']
                }] }] });

/**
 * Check if user is logged and if yes do auto login e.g. redirect to afterGoodLogin URL.
 * This guard service apply only on /login route.
 */
class AutologinService {
    constructor(authService, r, auth_urls) {
        this.authService = authService;
        this.r = r;
        this.auth_urls = auth_urls;
    }
    canActivate(ars, rss) {
        // get loggedUser info after successful username:password login
        const loggedUser = this.authService.getLoggedUserInfo();
        // console.log('GUARD::autoLogin:loggedUser: ', loggedUser);
        const isAlreadyLogged = !!loggedUser && !!loggedUser.username;
        // redirect
        if (isAlreadyLogged) {
            const afterGoodLoginURL = this.auth_urls.afterGoodLogin.replace('{loggedUserRole}', loggedUser.role);
            this.r.navigateByUrl(afterGoodLoginURL);
        }
        return true; // always activate this route
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: AutologinService, deps: [{ token: AuthService }, { token: i2.Router }, { token: 'AUTH_URLS' }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: AutologinService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: AutologinService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: AuthService }, { type: i2.Router }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['AUTH_URLS']
                }] }] });

class NgboostAuthModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: NgboostAuthModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.3", ngImport: i0, type: NgboostAuthModule }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: NgboostAuthModule, providers: [
            AuthService,
            CookieService,
            JwtTokenInterceptor,
            IsLoggedService,
            HasRoleService,
            AutologinService,
        ] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: NgboostAuthModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [],
                    declarations: [],
                    providers: [
                        AuthService,
                        CookieService,
                        JwtTokenInterceptor,
                        IsLoggedService,
                        HasRoleService,
                        AutologinService,
                    ],
                    exports: []
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { AuthService, AutologinService, CookieService, HasRoleService, IsLoggedService, JwtTokenInterceptor, NgboostAuthModule };
//# sourceMappingURL=ngboost-auth.mjs.map
