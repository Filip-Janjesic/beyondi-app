import { Injectable, Inject } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "../auth.service";
import * as i2 from "@angular/router";
/**
 * Check if user has required role: admin, customer. If not redirect to /login page.
 */
export class HasRoleService {
    constructor(authService, r, auth_urls) {
        this.authService = authService;
        this.r = r;
        this.auth_urls = auth_urls;
    }
    canActivate(ars, rss) {
        // get loggedUser info after successful username:password login
        const loggedUser = this.authService.getLoggedUserInfo();
        // console.log('GUARD::hasRole:loggedUser: ', loggedUser);
        // get current URL and check if user's role (admin, customer) is contained in it
        const currentUrl = rss.url; // '/admin/dashboard'
        // console.log('GUARD::hasRole:currentUrl: ', currentUrl);
        let tf = false;
        if (loggedUser) {
            tf = currentUrl.indexOf(loggedUser.role) !== -1;
        }
        if (!tf) {
            this.r.navigateByUrl(this.auth_urls.afterBadLogin);
            console.error(new Error('Guard blocks this route because user doesn\'t have good role. Redirection to /login page.'));
        }
        return tf;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: HasRoleService, deps: [{ token: i1.AuthService }, { token: i2.Router }, { token: 'AUTH_URLS' }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: HasRoleService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: HasRoleService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i1.AuthService }, { type: i2.Router }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['AUTH_URLS']
                }] }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGFzUm9sZS5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbmdib29zdC1hdXRoL3NyYy9saWIvcm91dGVHdWFyZHMvaGFzUm9sZS5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDOzs7O0FBS25EOztHQUVHO0FBRUgsTUFBTSxPQUFPLGNBQWM7SUFFekIsWUFDVSxXQUF3QixFQUN4QixDQUFTLEVBQ1ksU0FBYztRQUZuQyxnQkFBVyxHQUFYLFdBQVcsQ0FBYTtRQUN4QixNQUFDLEdBQUQsQ0FBQyxDQUFRO1FBQ1ksY0FBUyxHQUFULFNBQVMsQ0FBSztJQUN6QyxDQUFDO0lBR0wsV0FBVyxDQUFDLEdBQTJCLEVBQUUsR0FBd0I7UUFFL0QsK0RBQStEO1FBQy9ELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN4RCwwREFBMEQ7UUFFMUQsZ0ZBQWdGO1FBQ2hGLE1BQU0sVUFBVSxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxxQkFBcUI7UUFDakQsMERBQTBEO1FBRTFELElBQUksRUFBRSxHQUFHLEtBQUssQ0FBQztRQUNmLElBQUksVUFBVSxFQUFFLENBQUM7WUFDZixFQUFFLEdBQUcsVUFBVSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDbEQsQ0FBQztRQUVELElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQztZQUNSLElBQUksQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDbkQsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLEtBQUssQ0FBQywyRkFBMkYsQ0FBQyxDQUFDLENBQUM7UUFDeEgsQ0FBQztRQUVELE9BQU8sRUFBRSxDQUFDO0lBQ1osQ0FBQzs4R0E5QlUsY0FBYyxtRUFLZixXQUFXO2tIQUxWLGNBQWM7OzJGQUFkLGNBQWM7a0JBRDFCLFVBQVU7OzBCQU1OLE1BQU07MkJBQUMsV0FBVyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUm91dGVyLCBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBSb3V0ZXJTdGF0ZVNuYXBzaG90IH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IEF1dGhTZXJ2aWNlIH0gZnJvbSAnLi4vYXV0aC5zZXJ2aWNlJztcblxuXG4vKipcbiAqIENoZWNrIGlmIHVzZXIgaGFzIHJlcXVpcmVkIHJvbGU6IGFkbWluLCBjdXN0b21lci4gSWYgbm90IHJlZGlyZWN0IHRvIC9sb2dpbiBwYWdlLlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgSGFzUm9sZVNlcnZpY2Uge1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgYXV0aFNlcnZpY2U6IEF1dGhTZXJ2aWNlLFxuICAgIHByaXZhdGUgcjogUm91dGVyLFxuICAgIEBJbmplY3QoJ0FVVEhfVVJMUycpIHByaXZhdGUgYXV0aF91cmxzOiBhbnksIC8vIHthZnRlckdvb2RMb2dpbjogLCBhZnRlckJhZExvZ2luOiAsIGFmdGVyTG9nb3V0OiB9XG4gICkgeyB9XG5cblxuICBjYW5BY3RpdmF0ZShhcnM6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QsIHJzczogUm91dGVyU3RhdGVTbmFwc2hvdCkge1xuXG4gICAgLy8gZ2V0IGxvZ2dlZFVzZXIgaW5mbyBhZnRlciBzdWNjZXNzZnVsIHVzZXJuYW1lOnBhc3N3b3JkIGxvZ2luXG4gICAgY29uc3QgbG9nZ2VkVXNlciA9IHRoaXMuYXV0aFNlcnZpY2UuZ2V0TG9nZ2VkVXNlckluZm8oKTtcbiAgICAvLyBjb25zb2xlLmxvZygnR1VBUkQ6Omhhc1JvbGU6bG9nZ2VkVXNlcjogJywgbG9nZ2VkVXNlcik7XG5cbiAgICAvLyBnZXQgY3VycmVudCBVUkwgYW5kIGNoZWNrIGlmIHVzZXIncyByb2xlIChhZG1pbiwgY3VzdG9tZXIpIGlzIGNvbnRhaW5lZCBpbiBpdFxuICAgIGNvbnN0IGN1cnJlbnRVcmwgPSByc3MudXJsOyAvLyAnL2FkbWluL2Rhc2hib2FyZCdcbiAgICAvLyBjb25zb2xlLmxvZygnR1VBUkQ6Omhhc1JvbGU6Y3VycmVudFVybDogJywgY3VycmVudFVybCk7XG5cbiAgICBsZXQgdGYgPSBmYWxzZTtcbiAgICBpZiAobG9nZ2VkVXNlcikge1xuICAgICAgdGYgPSBjdXJyZW50VXJsLmluZGV4T2YobG9nZ2VkVXNlci5yb2xlKSAhPT0gLTE7XG4gICAgfVxuXG4gICAgaWYgKCF0Zikge1xuICAgICAgdGhpcy5yLm5hdmlnYXRlQnlVcmwodGhpcy5hdXRoX3VybHMuYWZ0ZXJCYWRMb2dpbik7XG4gICAgICBjb25zb2xlLmVycm9yKG5ldyBFcnJvcignR3VhcmQgYmxvY2tzIHRoaXMgcm91dGUgYmVjYXVzZSB1c2VyIGRvZXNuXFwndCBoYXZlIGdvb2Qgcm9sZS4gUmVkaXJlY3Rpb24gdG8gL2xvZ2luIHBhZ2UuJykpO1xuICAgIH1cblxuICAgIHJldHVybiB0ZjtcbiAgfVxuXG5cbn1cbiJdfQ==